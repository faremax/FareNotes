
## 2017年校招全国统一模拟笔试(第三场)编程题集合

> 地址：[2017年校招全国统一模拟笔试(第三场)编程题集合](https://www.nowcoder.com/test/5217106/summary)

### 变换次数 (AC)

牛牛想对一个数做若干次变换，直到这个数只剩下一位数字。
变换的规则是：将这个数变成 所有位数上的数字的乘积。比如285经过一次变换后转化成2*8*5=80.
问题是，要做多少次变换，使得这个数变成个位数。
输入描述:
输入一个整数。小于等于2,000,000,000。


输出描述:
输出一个整数，表示变换次数。

输入例子1:
> 285

输出例子1:
> 2

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.on('line', function(line) {
  var times = 0;
  var str = line.trim();
  calc(str);
  console.log(times);
  function calc(str){
    if(str.length === 1){
      return times;
    } else {
      times++;
      calc(str.split('').map(Number).reduce(function(a, b){
        return a * b;
      }, 1) + '');
    }
  }
});
```


### 神奇数 (AC)

给出一个区间[a, b]，计算区间内“神奇数”的个数。
神奇数的定义：存在不同位置的两个数位，组成一个两位数（且不含前导0），且这个两位数为质数。
比如：153，可以使用数字3和数字1组成13，13是质数，满足神奇数。同样153可以找到31和53也为质数，只要找到一个质数即满足神奇数。
输入描述:
输入为两个整数a和b，代表[a, b]区间 (1 ≤ a ≤ b ≤ 10000)。


输出描述:
输出为一个整数，表示区间内满足条件的整数个数

输入例子1:
> 11 20

输出例子1:
> 6

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.on('line', function(line) {
  var num = line.trim().split(' ').map(Number);
  var count = 0;
  for(var i = num[0]; i <= num[1]; i++){
    if(isMagicNum(i)){
      count++;
    }
  }
  console.log(count);

  function isMagicNum(num){
    arr = ('' + num).split('');
    var len = arr.length;
    for(var i = 0; i < arr.length; i++){
      for(var j = 0; j < arr.length; j++){
        if(i !== j && arr[j] !== '0' && arr[i] !== '0'){
          if(isPrime(parseInt(arr[i] + arr[j]))){
            return true;
          } else if(isPrime(parseInt(arr[j] + arr[i]))){
            return true;
          }
        }
      }
    }
    return false;
  }

  function isPrime(num){
    if((num & 1) === 0) return num === 2;
    var limit = Math.sqrt(num);
    for(var i = 3; i <= limit; i += 2){
      if(num % i === 0) return false;
    }
    return true;
  }

});
```

### 添加字符 (AC)

牛牛手里有一个字符串A，羊羊的手里有一个字符串B，B的长度大于等于A，所以牛牛想把A串变得和B串一样长，这样羊羊就愿意和牛牛一起玩了。
而且A的长度增加到和B串一样长的时候，对应的每一位相等的越多，羊羊就越喜欢。比如"abc"和"abd"对应相等的位数为2，为前两位。
牛牛可以在A的开头或者结尾添加任意字符，使得长度和B一样。现在问牛牛对A串添加完字符之后，不相等的位数最少有多少位？
输入描述:
第一行为字符串A，第二行为字符串B，A的场地小于等于B的长度，B的长度小于等于50.字符均为小写字母。


输出描述:
输出一个整数表示A串添加完字符之后，不相等的位数最少有多少位？

输入例子1:
> abe
> cabc

输出例子1:
> 1

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
var currLine = 0;
var strA, strB;
rl.on('line', function(line) {
  if(currLine === 0){
    strA = line.trim();
    currLine++;
  } else {
    strB = line.trim();
    if(strA.length === strB.length){
      console.log(getDiffLen(strA, strB));
    } else {
      console.log(strA.length - maxCommonSubStrLen(strA, strB))
    }
    currLine = 0, strA = strB = '';
  }

  function maxCommonSubStrLen(a, b){
    var maxLen = 0, len = 0;
    var lenA = a.length, lenB = b.length;
    var temp;
    for(var i = 0; i < lenB - lenA + 1; i++){
      temp = b.slice(i, i + lenA);
      len = getCommonLen(a, temp);
      maxLen = len < maxLen ? maxLen : len;
    }
    return maxLen;
  }
  function getDiffLen(a, b){
    if(a.length !== b.length) throw new Error('Two parameters in "getDiffLen" should be same length.');
    var arrA = a.split('');
    var arrB = b.split('');
    var num = 0;
    arrA.forEach(function(item, index){
      if(item !== arrB[index]){
        num++;
      }
    });
    return num;
  }
  function getCommonLen(a, b){
    if(a.length !== b.length) throw new Error('Two parameters in "getDiffLen" should be same length.');
    return a.length - getDiffLen(a, b);
  }
});
```

### 数组变换 (AC)

牛牛有一个数组，里面的数可能不相等，现在他想把数组变为：所有的数都相等。问是否可行。
牛牛可以进行的操作是：将数组中的任意一个数改为这个数的两倍。
这个操作的使用次数不限，也可以不使用，并且可以对同一个位置使用多次。

输入描述:
输入一个正整数N (N <= 50)
接下来一行输入N个正整数，每个数均小于等于1e9.


输出描述:
假如经过若干次操作可以使得N个数都相等，那么输出"YES", 否则输出"NO"

输入例子1:
> 2
> 1 2

输出例子1:
> YES

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
var currLine = 0;
var len, nums;
rl.on('line', function(line) {
  if(currLine === 0){
    len = parseInt(line);
    currLine++;
  } else {
    nums = line.trim().split(' ').map(Number);
    console.log(yesorno(nums));
    len = currLine = 0, nums = null;

    function yesorno(arr){
      var flag = null, temp;
      for(var i = 0; i < len; i++){
        temp = nums[i];
        while((temp & 1) === 0){
          temp /= 2;
        }
        if(flag){
          if(temp === flag) {
            continue;
          } else {
            return 'NO';
          }
        } else {
          flag = temp;
        }
      }
      return 'YES'
    }
  }
});
```

### 排序子序列 (AC)

牛牛定义排序子序列为一个数组中一段连续的子序列,并且这段子序列是非递增或者非递减排序的。牛牛有一个长度为n的整数数组A,他现在有一个任务是把数组A分为若干段排序子序列,牛牛想知道他最少可以把这个数组分为几段排序子序列.
如样例所示,牛牛可以把数组A划分为[1,2,3]和[2,2,1]两个排序子序列,至少需要划分为2个排序子序列,所以输出2

输入描述:
输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)

第二行包括n个整数A_i(1 ≤ A_i ≤ 10^9),表示数组A的每个数字。

输出描述:
输出一个整数表示牛牛可以将A最少划分为多少段排序子序列

输入例子1:
> 6
> 1 2 3 2 2 1

输出例子1:
> 2

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
var currLine = 0;
var len, nums;
rl.on('line', function(line) {
  if(currLine === 0){
    len = parseInt(line);
    currLine++;
  } else {
    nums = line.trim().split(' ').map(Number);
    var count = 1;
    var isAsc = null;
    for(var i = 1, j = 0; i < len; i++){
      if(nums[i] < nums[i - 1]){
        if(isAsc === null) isAsc = true;
        else if(!isAsc) {
          count++;
          isAsc = null;
        }
      } else if(nums[i] > nums[i - 1]){
        if(isAsc === null) isAsc = false;
        else if(isAsc){
          count++;
          isAsc = null;
        }
      }
    }
    console.log(count);
    len = currLine = 0, nums = null;
  }
});
```

###  组队竞赛 (Memory out)

牛牛举办了一次编程比赛,参加比赛的有3*n个选手,每个选手都有一个水平值a_i.现在要将这些选手进行组队,一共组成n个队伍,即每个队伍3人.牛牛发现队伍的水平值等于该队伍队员中第二高水平值。
例如:
一个队伍三个队员的水平值分别是3,3,3.那么队伍的水平值是3
一个队伍三个队员的水平值分别是3,2,3.那么队伍的水平值是3
一个队伍三个队员的水平值分别是1,5,2.那么队伍的水平值是2
为了让比赛更有看点,牛牛想安排队伍使所有队伍的水平值总和最大。
如样例所示:
如果牛牛把6个队员划分到两个队伍
如果方案为:
team1:{1,2,5}, team2:{5,5,8}, 这时候水平值总和为7.
而如果方案为:
team1:{2,5,8}, team2:{1,5,5}, 这时候水平值总和为10.
没有比总和为10更大的方案,所以输出10.

输入描述:
输入的第一行为一个正整数n(1 ≤ n ≤ 10^5)
第二行包括3*n个整数a_i(1 ≤ a_i ≤ 10^9),表示每个参赛选手的水平值.

输出描述:
输出一个整数表示所有队伍的水平值总和最大值.

输入例子1:
> 2
> 5 2 8 5 1 5

输出例子1:
> 10

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
var currLine = 0;
var group, nums;
rl.on('line', function(line) {
  if(currLine === 0){
    group = parseInt(line);
    currLine++;
  } else {
    nums = line.trim().split(' ').map(Number).sort(function(a, b){
      return b - a;
    });
    var len = nums.length;
    var ans = 0;
    for(var i = 1; i < len - group; i += 2){
      ans += nums[i];
    }
    console.log(ans);
    group = currLine = 0, nums = null;
  }
});
```


### 牛牛的数列 (AC)

牛牛现在有一个n个数组成的数列,牛牛现在想取一个连续的子序列,并且这个子序列还必须得满足:最多只改变一个数,就可以使得这个连续的子序列是一个严格上升的子序列,牛牛想知道这个连续子序列最长的长度是多少。
输入描述:
输入包括两行,第一行包括一个整数n(1 ≤ n ≤ 10^5),即数列的长度;
第二行n个整数a_i, 表示数列中的每个数(1 ≤ a_i ≤ 10^9),以空格分割。

输出描述:
输出一个整数,表示最长的长度。

输入例子1:
> 6
> 7 2 3 1 5 6

输出例子1:
> 5

```js
var readline = require('readline');
var quantity = 0, len = 0;
var max = 0, temp = 0, flag = 0;
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
var currLine = 0;
var len, nums;
rl.on('line', function(line) {
  if(currLine === 0){
    len = parseInt(line);
    currLine++;
  } else {
    nums = line.trim().split(' ').map(Number);
    var ans = 1;
    var pre = [0], post = [0];

    nums.shift(Infinity);
    nums.push(Infinity);
    for(var i = 1; i <= len; i++){
      pre[i] = nums[i - 1] < nums[i] ? pre[i - 1] + 1 : 1;
    }
    for(var i = len; i > 0; i--){
      post[i] = nums[i] < nums[i + 1] ? post[i+1] + 1 : 1;
    }

    for (var i = 1; i <= len; i++){
      if (nums[i + 1] - nums[i - 1] >= 2) ans = Math.max(ans, pre[i - 1] + post[i + 1] + 1);
    }
    console.log(ans);
    len = currLine = 0, nums = null;
  }
});
```

## 训练部队 (AC)

小牛牛是牛牛王国的将军,为了训练出精锐的部队,他会对新兵进行训练。部队进入了n个新兵,每个新兵有一个战斗力值和潜力值,当两个新兵进行决斗时,总是战斗力值高的获胜。获胜的新兵的战斗力值就会变成对手的潜力值 + 自己的战斗力值 - 对手的战斗力值。败者将会被淘汰。若两者战斗力值一样,则会同归于尽,双双被淘汰(除了考察的那个新兵之外，其他新兵之间不会发生战斗) 。小牛牛想知道通过互相决斗之后新兵中战斗力值+潜力值最高的一个可能达到多少,你能帮助小牛牛将军求出来吗?

输入描述:
输入包括n+1行,第一行包括一个整数n(1 ≤ n ≤ 10^5);
接下来的n行,每行两个整数x和y(1 ≤ x,y ≤ 10^9)

输出描述:
输出一个整数,表示新兵中战斗力值+潜力值最高的一个能达到多少。

示例输入
> 2
> 1 2
> 2 1

示例输出
> 4

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
var quantity = 0, len = 0;
var sum = 0, temp = 0, flag = 0;
rl.on('line', function(line) {
  if(quantity === 0){
    quantity = len = parseInt(line);
  } else {
    var input = line.trim().split(' ').map(Number);
    if(input[0] >= input[1]){
      temp = input[0] + input[1];
      flag = flag > temp ? flag : temp;
    } else {
      temp = 2 * input[0];
      flag = flag > temp ? flag : temp;
      sum += input[1] - input[0];
    }
    quantity--;
    if(quantity === 0){
      console.log(sum + flag);
    }
  }
});
```

## 2017年校招全国统一模拟笔试(第五场)编程题集合

> 地址：[2017年校招全国统一模拟笔试(第五场)编程题集合](https://www.nowcoder.com/test/5986669/summary)

# 偶串 (AC)

如果一个字符串由两个相同字符串连接而成,就称这个字符串是偶串。例如"xyzxyz"和"aaaaaa"是偶串,但是"ababab"和"xyzxy"却不是。
牛牛现在给你一个只包含小写字母的偶串s,你可以从字符串s的末尾删除1和或者多个字符,保证删除之后的字符串还是一个偶串,牛牛想知道删除之后得到最长偶串长度是多少。

输入描述:
输入包括一个字符串s,字符串长度length(2 ≤ length ≤ 200),保证s是一个偶串且由小写字母构成

输出描述:
输出一个整数,表示删除之后能得到的最长偶串长度是多少。保证测试数据有非零解

输入例子1:
> abaababaab

输出例子1:
> 6

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.on('line', function(line) {
  var str = line.trim();
  str = strWithoutLast(str);
  while(str.length){
    if(str.length & 1 === 1){
      str = strWithoutLast(str);
    }
    if(isEvenStr(str)){
      console.log(str.length);
      break;
    } else {
      str = strWithoutLast(str);
    }
  }
  function isEvenStr(str){
    var len = str.length;
    var left = str.slice(0, len / 2);
    var right = str.slice(len / 2, len);
    return left === right;
  }
  function strWithoutLast(str){
    var len = str.length;
    return str.slice(0, len - 1);
  }
});
```

## 制造回文 (AC)

牛牛有一些字母卡片,每张卡片上都有一个小写字母,所有卡片组成一个字符串s。牛牛一直认为回文这种性质十分优雅,于是牛牛希望用这些卡片拼凑出一些回文串,但是有以下要求:
1、每张卡片只能使用一次
2、要求构成的回文串的数量最少
牛牛想知道用这些字母卡片,最少能拼凑出多少个回文串。
例如: s = "abbaa",输出1,因为最少可以拼凑出"ababa"这一个回文串
s = "abc", 输出3,因为最少只能拼凑出"a","b","c"这三个回文串

输入描述:
输入包括一行,一个字符串s,字符串s长度length(1 ≤ length ≤ 1000).
s中每个字符都是小写字母

输出描述:
输出一个整数,即最少的回文串个数。

输入例子1:
> abc

输出例子1:
> 3

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.on('line', function(line) {
  var alpha = 26;
  var strArr = line.trim().split('');
  var arr = [];
  var odd = 0;
  while(alpha){arr.push(0); alpha--;}
  for(var i = 0, len = strArr.length; i < len; i++){
    var index = strArr[i].charCodeAt(0) - 97;
    arr[index]++;
  }
  arr.forEach(function(item){
    if(item & 1 === 1){
      odd++;
    }
  });
  console.log(odd);
});
```

## 猜数 (Memory out)

牛牛和羊羊在玩一个有趣的猜数游戏。在这个游戏中,牛牛玩家选择一个正整数,羊羊根据已给的提示猜这个数字。第i个提示是"Y"或者"N",表示牛牛选择的数是否是i的倍数。
例如,如果提示是"YYNYY",它表示这个数使1,2,4,5的倍数,但不是3的倍数。
注意到一些提示会出现错误。例如: 提示"NYYY"是错误的,因为所有的整数都是1的倍数,所以起始元素肯定不会是"N"。此外,例如"YNNY"的提示也是错误的,因为结果不可能是4的倍数但不是2的倍数。
现在给出一个整数n,表示已给的提示的长度。请计算出长度为n的合法的提示的个数。
例如 n = 5:
合法的提示有:
YNNNN YNNNY YNYNN YNYNY YYNNN YYNNY
YYNYN YYNYY YYYNN YYYNY YYYYN YYYYY
所以输出12

输入描述:
输入包括一个整数n(1 ≤ n ≤ 10^6),表示已给提示的长度。

输出描述:
输出一个整数,表示合法的提示个数。因为答案可能会很大,所以输出对于1000000007的模

输入例子1:
> 5

输出例子1:
> 12

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
rl.on('line', function(line) {
  var mod = 1000000007;
  var ans = 1;
  var n = parseInt(line.trim());
  var vis = [];
  debugger;
  for(var i = 2; i <= n; i++){
    if(vis[i]) continue;
    for(var j = 2 * i; j <= n; j += i){
        vis[j] = 1;
    }
    var tmp = n;
    var cnt = 0;
    while(tmp >= i){
        tmp /= i;
        cnt++;
    }
    ans = ans * (cnt + 1) % mod;
  }
  console.log(ans);
});
```

## DNA

DNA片段
时间限制：1秒
空间限制：32768K
牛牛从生物科研工作者那里获得一段字符串数据s,牛牛需要帮助科研工作者从中找出最长的DNA序列。DNA序列指的是序列中只包括'A','T','C','G'。牛牛觉得这个问题太简单了,就把问题交给你来解决。
例如: s = "ABCBOATER"中包含最长的DNA片段是"AT",所以最长的长度是2。
输入描述:
输入包括一个字符串s,字符串长度length(1 ≤ length ≤ 50),字符串中只包括大写字母('A'~'Z')。


输出描述:
输出一个整数,表示最长的DNA片段

输入例子1:
ABCBOATER

输出例子1:
2

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
rl.on('line', function(line) {
  var str = line.trim();
  var len =  line.match(/[ATCG]*/g).reduce(function(a, b){
    return a < b.length ? b.length : a;
  }, 0);
  console.log(len);
});
```

## 彩色瓷砖

牛牛喜欢彩色的东西,尤其是彩色的瓷砖。牛牛的房间内铺有L块正方形瓷砖。每块砖的颜色有四种可能:红、绿、蓝、黄。给定一个字符串S, 如果S的第i个字符是'R', 'G', 'B'或'Y',那么第i块瓷砖的颜色就分别是红、绿、蓝或者黄。
牛牛决定换掉一些瓷砖的颜色,使得相邻两块瓷砖的颜色均不相同。请帮牛牛计算他最少需要换掉的瓷砖数量。

输入描述:
输入包括一行,一个字符串S,字符串长度length(1 ≤ length ≤ 10),字符串中每个字符串都是'R', 'G', 'B'或者'Y'。

输出描述:
输出一个整数,表示牛牛最少需要换掉的瓷砖数量

输入例子1:
> RRRRRR

输出例子1:
> 3

```js
var readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
rl.on('line', function(line) {
  var str = line.trim();
  var arr = str.match(/([RGBY])\1+/g);
  var num = 0;
  if(arr){
    num = arr.reduce(function(a, b){
      return Math.floor(b.length / 2) + a;
    }, 0);
  }
  console.log(num);
});
```
